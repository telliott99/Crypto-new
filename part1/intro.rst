###################
Practical Passwords
###################

**Password strategy**

These days it seems that every useful website or service requires a password.  Ideally, passwords should be **strong**.  A strong password should require a very large number of attempts before an attacker could guess it successfully.

``abc123`` and ``pw`` are not strong passwords.

Check to see if you've been `pwned <https://haveibeenpwned.com>`_.

To achieve strength, the best passwords would be a random string of bits.  However, for readability, they are usually represented as strings of printable characters.  Also, to mitigate the possibility that a password has been compromised, policy typically dictates that they change periodically.

Most people cannot remember a regularly changing set of random strings.  One solution is to write the strings to a file and encrypt that, and then remember a single password that unlocks the file.  The master password might be generated from a series of words with additional punctuation and unusual capitalization, something like:

``*I*amthe_greatesT#``

or

``*I*amthe_greatesT#zyxw987``

I think that having a list of passwords encrypted and stored on disk is a good solution for most situations, e.g. my Amazon account or work email, where for the most part, any damage that might be done with a compromised credential can be reversed.  Advantages include the ability to cut and paste, and cloud storage available to multiple devices.  When combined with challenge-response via smartphone it is quite robust.  

On the other hand, one could rely on physical possession of a password on a sheet of paper, entering it at the keyboard for each use.  This is a good approach for the most sensitive passwords, such as banking site passwords.

Security is ultimately a relative judgement.  If the NSA is interested in you, it will be very difficult to keep your secrets.

Here is a simple Python script to generate passwords:

.. sourcecode:: python

    import random
    random.seed(153)
    L1 = list('abcdefghijklmnopqrstuvwxyz')
    L2 = list('0123456789')
    L = [c + d for c in L1 for d in L2]
    N = 10
    pL = [random.choice(L) for i in range(N)]
    print(''.join(pL))
    
Test it by pasting in the Python interpreter and then doing:

>>> print(''.join(pL))
z1d8b9n3v2q2v7m5q1k5
>>>

To generate passwords which are actually random, comment out the second line.

Modify the script to accept the length as an argument on the command line, or just edit the value of *N*.  If the password must be typed rather than copy-pasted, you could offset the groups so it's easier to read:

.. sourcecode:: python

    sep = ' '
    print(sep.join(pL))

>>> python pwgen.py
z8 b9 g7 w1 x2 o7 p5 v8 z3 x0
>>>

**Knowledge-based authentication**

In general, some kind of two-factor authentication is a good thing.  One form of that is "Knowledge-based", where you login with username and password, and then the website challenges you with a question.

The classic one is, of course, what is your mother’s maiden name?  But there are plenty of others, as I’m sure you know.

A twist on this is when the server generates a question for you on its own.  This happened for me with a Chase credit card, where they came up with a question (don't ask me how) and I didn't know the answer.  Since they also had an old phone number, I was stuck.

New challenge questions can also happen by design.  The site queries one of the credit agencies for your old addresses, presents a list, and then asks at which ones have you lived or *not* lived.

My take on this is that it is fine, with one proviso.  The website *must allow you to set your own answers*, and they should allow anything.  For example:

::

    Q: Where was your maternal grandmother born?
    A: x2z0j7v3m3k9b3

It’s also helpful if they will let  you do a reset.

My favorite:

::

    Q: What is your mother’s birthday (mmdd)
    A: 1963

Of course, 19 is not a valid month.  But that’s what is great about it!

Just keep the Q&A pairs in a file.  If it's for a banking site, write it down, or encrypt the file on disk.  Copy-and-paste.

**Password complexity**

You've surely seen sites that require you to pick characters from certain sets, for example, including at least one digit, or one punctuation character.

These rules are misguided.  The reason is simply that the number of permutations *P* generated by a randomization method depends on the size of character set *C* and the length of the password *n* in the following way:

.. math::

    P = C^n 

That is, *n* is much more important than *C*.  Taking logarithms

    log P = n(log C)

We see the issue:  *P* goes linearly with *C* but exponentially with *n*.

As an example, a character set of *C* equal to 32 (lowercase English alphabet plus the digits 1-6) gives a length 10 password set with the number of permutations equal to 

.. math::

    P = 32^{10} = (2^5)^{10} = 2^{50}
    
If we increase the size of the character set to 64 (base64-encoding) we get

.. math::

    P = 64^{10} = (2^{6})^{10} = 2^{60}

permutations, an increase of a factor of :math:`2^{10}`.  Doubling the size of the character set doubles the number of permutations for each character.

On the other hand, retaining the smaller character set but increasing the length by just two gives exactly the same number of permutations.  

.. math::

    P = 32^{12} = (2^{5})^{12} = 2^{60}
    
We can overcome the deficiency of a small character set by a small increase in length.  For that matter, we could decrease the character set to 8 tokens and increase the length from 10 to 20 and still have the same complexity.

.. math::

    P = 8^{16} = (2^{3})^{20} = 2^{60}

Our primary goal in restricting the character set is to make it easy to enter passwords by hand.  I could note that the letters and digits are on separate screens on my iPhone, so it would make sense to restrict the character set to just the 26 lowercase characters.  On the other hand, I am so old-fashioned that I almost never enter passwords on my phone.

In the example given above, we have a set of elements containing pairs of characters with a letter followed by a digit, like ``z5``, and the size of the set is 260.  A password of length 20 total characters like ``z8b9g7w1x2o7p5v8z3x0`` has a complexity

>>> 260**10
1411670956533760000000000L

This compares with a password made from single characters randomly chosen from the combined set of letters plus digits and of the same total length

>>> 36**20
13367494538843734067838845976576L

In the latter case, the positions are all independent and the number of permutations is greater by a factor of nearly 10 million.  But we can easily make up for that by a modest increase in password length.  Increasing the length to 13 pairs (26 total characters) gives a permutation space that is twice as large as 20 total characters from the 36 character set.

>>> 1.0 * 260**13 / 36**20
1.8561091354807857

The smaller the character set, the easier it is to type.  

And password length is everything.  That is why I prefer the approach shown above for typed passwords.  If there is no need to type, something like this suffices from the command line:

.. sourcecode:: bash

    > openssl rand 12 -base64
    esDld/a+nVvLV5he

Perhaps even better

.. sourcecode:: bash

    > openssl rand 12 -hex
    ba46fc688334fd6fcb113e04

We use the utility ``openssl`` to generate 12 random bytes and then convert the result to base64 or hexadecimal.

**autocomplete="on"**

As an aside, some websites use a form element that instructs the browser not to allow the OS to remember your passwords.  It looks like this:

.. sourcecode:: bash

    <input class="login" type="text" value="" 
    size="20"  autocomplete="off">
    
This is easy to turn off:

http://telliott99.blogspot.com/2010/12/turn-autocompleteon.html

This is not just annoying, it's wrong.  Requiring users to type in their passwords each time is a strong incentive to use weak passwords.  That's bad.  

Of course there is an alternative risk, that the user will somehow "save" his password in an internet cafe, or forget to logoff when done.  That is to me a lesser a problem, but if it bothers you, well, don't turn off **autocomplete="off"**.